From f302a46801682bf97a1d5808458b09660765ad88 Mon Sep 17 00:00:00 2001
From: Yun Jiang <Yun.Jiang@realvnc.com>
Date: Thu, 27 Oct 2016 17:12:38 +0100
Subject: [PATCH 1/4] Enable support for AR6003 firmware hw2.1.1 3.4

---
 drivers/net/wireless/ath/ath6kl/cfg80211.c |   4 +-
 drivers/net/wireless/ath/ath6kl/cfg80211.h |   4 +-
 drivers/net/wireless/ath/ath6kl/core.h     |  27 +++++-
 drivers/net/wireless/ath/ath6kl/init.c     |   8 ++
 drivers/net/wireless/ath/ath6kl/main.c     |   6 +-
 drivers/net/wireless/ath/ath6kl/wmi.c      | 127 ++++++++++++++++++-----------
 drivers/net/wireless/ath/ath6kl/wmi.h      |  61 ++++++++------
 7 files changed, 157 insertions(+), 80 deletions(-)

diff --git a/drivers/net/wireless/ath/ath6kl/cfg80211.c b/drivers/net/wireless/ath/ath6kl/cfg80211.c
index 56d9bed..9556d4e 100644
--- a/drivers/net/wireless/ath/ath6kl/cfg80211.c
+++ b/drivers/net/wireless/ath/ath6kl/cfg80211.c
@@ -734,8 +734,8 @@ void ath6kl_cfg80211_connect_event(struct ath6kl_vif *vif, u16 channel,
 				   u8 *bssid, u16 listen_intvl,
 				   u16 beacon_intvl,
 				   enum network_type nw_type,
-				   u8 beacon_ie_len, u8 assoc_req_len,
-				   u8 assoc_resp_len, u8 *assoc_info)
+				   u16 beacon_ie_len, u16 assoc_req_len,
+				   u16 assoc_resp_len, u8 *assoc_info)
 {
 	struct ieee80211_channel *chan;
 	struct ath6kl *ar = vif->ar;
diff --git a/drivers/net/wireless/ath/ath6kl/cfg80211.h b/drivers/net/wireless/ath/ath6kl/cfg80211.h
index b59becd..7254010 100644
--- a/drivers/net/wireless/ath/ath6kl/cfg80211.h
+++ b/drivers/net/wireless/ath/ath6kl/cfg80211.h
@@ -35,8 +35,8 @@ void ath6kl_cfg80211_connect_event(struct ath6kl_vif *vif, u16 channel,
 				   u8 *bssid, u16 listen_intvl,
 				   u16 beacon_intvl,
 				   enum network_type nw_type,
-				   u8 beacon_ie_len, u8 assoc_req_len,
-				   u8 assoc_resp_len, u8 *assoc_info);
+				   u16 beacon_ie_len, u16 assoc_req_len,
+				   u16 assoc_resp_len, u8 *assoc_info);
 
 void ath6kl_cfg80211_disconnect_event(struct ath6kl_vif *vif, u8 reason,
 				      u8 *bssid, u8 assoc_resp_len,
diff --git a/drivers/net/wireless/ath/ath6kl/core.h b/drivers/net/wireless/ath/ath6kl/core.h
index 26b0f92..f0f06ff 100644
--- a/drivers/net/wireless/ath/ath6kl/core.h
+++ b/drivers/net/wireless/ath/ath6kl/core.h
@@ -136,6 +136,27 @@ enum ath6kl_fw_capability {
 	 */
 	ATH6KL_FW_CAPABILITY_HEART_BEAT_POLL,
 
+	/*
+	 * Firmware supports mac address based ACL with
+	 * white/black list
+	 */
+	ATH6KL_FW_CAPABILITY_MAC_ACL,
+
+	/*
+	* Firmware with capability regdomain-v2 can support
+	* set regdomain immediately. The firmware without this
+	* capability need start scan for new regdomain take effect
+	*/
+	ATH6KL_FW_CAPABILITY_REGDOMAIN_V2,
+
+	/*
+	 * Firmware capable to send more than 255 byte in IE
+	 * (assoc req ie, assoc resp ie, beacon ie) present in
+	 * connect event.
+	 */
+	ATH6KL_FW_CAPABILITY_LARGE_CONNECT_IE,
+
+
 	/* this needs to be last */
 	ATH6KL_FW_CAPABILITY_MAX,
 };
@@ -910,12 +931,12 @@ int ath6kl_control_tx(void *devt, struct sk_buff *skb,
 void ath6kl_connect_event(struct ath6kl_vif *vif, u16 channel,
 			  u8 *bssid, u16 listen_int,
 			  u16 beacon_int, enum network_type net_type,
-			  u8 beacon_ie_len, u8 assoc_req_len,
-			  u8 assoc_resp_len, u8 *assoc_info);
+			  u16 beacon_ie_len, u16 assoc_req_len,
+			  u16 assoc_resp_len, u8 *assoc_info);
 void ath6kl_connect_ap_mode_bss(struct ath6kl_vif *vif, u16 channel);
 void ath6kl_connect_ap_mode_sta(struct ath6kl_vif *vif, u16 aid, u8 *mac_addr,
 				u8 keymgmt, u8 ucipher, u8 auth,
-				u8 assoc_req_len, u8 *assoc_info, u8 apsd_info);
+				u16 assoc_req_len, u8 *assoc_info, u8 apsd_info);
 void ath6kl_disconnect_event(struct ath6kl_vif *vif, u8 reason,
 			     u8 *bssid, u8 assoc_resp_len,
 			     u8 *assoc_info, u16 prot_reason_status);
diff --git a/drivers/net/wireless/ath/ath6kl/init.c b/drivers/net/wireless/ath/ath6kl/init.c
index 4f316bd..d29e6ed 100644
--- a/drivers/net/wireless/ath/ath6kl/init.c
+++ b/drivers/net/wireless/ath/ath6kl/init.c
@@ -32,6 +32,9 @@
 #include "hif-ops.h"
 #include "htc-ops.h"
 
+static unsigned int ar6k_clock = 19200000;
+module_param(ar6k_clock, uint, 0644);
+
 static const struct ath6kl_hw hw_list[] = {
 	{
 		.id				= AR6003_HW_2_0_VERSION,
@@ -1463,6 +1466,8 @@ static int ath6kl_init_upload(struct ath6kl *ar)
 			return status;
 	}
 
+  ath6kl_bmi_reg_write(ar, 0x540678, ar6k_clock);
+
 	/* write EEPROM data to Target RAM */
 	status = ath6kl_upload_board_file(ar);
 	if (status)
@@ -1568,6 +1573,9 @@ static const struct fw_capa_str_map {
 	{ ATH6KL_FW_CAPABILITY_REGDOMAIN, "regdomain" },
 	{ ATH6KL_FW_CAPABILITY_SCHED_SCAN_V2, "sched-scan-v2" },
 	{ ATH6KL_FW_CAPABILITY_HEART_BEAT_POLL, "hb-poll" },
+	{ ATH6KL_FW_CAPABILITY_MAC_ACL, "mac-acl" },
+	{ ATH6KL_FW_CAPABILITY_REGDOMAIN_V2, "regdomain-v2" },
+	{ ATH6KL_FW_CAPABILITY_LARGE_CONNECT_IE, "large-connect-ie" },
 };
 
 static const char *ath6kl_init_get_fw_capa_name(unsigned int id)
diff --git a/drivers/net/wireless/ath/ath6kl/main.c b/drivers/net/wireless/ath/ath6kl/main.c
index 5839fc2..ac49230 100644
--- a/drivers/net/wireless/ath/ath6kl/main.c
+++ b/drivers/net/wireless/ath/ath6kl/main.c
@@ -422,7 +422,7 @@ void ath6kl_connect_ap_mode_bss(struct ath6kl_vif *vif, u16 channel)
 
 void ath6kl_connect_ap_mode_sta(struct ath6kl_vif *vif, u16 aid, u8 *mac_addr,
 				u8 keymgmt, u8 ucipher, u8 auth,
-				u8 assoc_req_len, u8 *assoc_info, u8 apsd_info)
+				u16 assoc_req_len, u8 *assoc_info, u8 apsd_info)
 {
 	u8 *ies = NULL, *wpa_ie = NULL, *pos;
 	size_t ies_len = 0;
@@ -624,8 +624,8 @@ static void ath6kl_check_ch_switch(struct ath6kl *ar, u16 channel)
 
 void ath6kl_connect_event(struct ath6kl_vif *vif, u16 channel, u8 *bssid,
 			  u16 listen_int, u16 beacon_int,
-			  enum network_type net_type, u8 beacon_ie_len,
-			  u8 assoc_req_len, u8 assoc_resp_len,
+			  enum network_type net_type, u16 beacon_ie_len,
+			  u16 assoc_req_len, u16 assoc_resp_len,
 			  u8 *assoc_info)
 {
 	struct ath6kl *ar = vif->ar;
diff --git a/drivers/net/wireless/ath/ath6kl/wmi.c b/drivers/net/wireless/ath/ath6kl/wmi.c
index 4f16d79..79c9a00 100644
--- a/drivers/net/wireless/ath/ath6kl/wmi.c
+++ b/drivers/net/wireless/ath/ath6kl/wmi.c
@@ -803,44 +803,43 @@ int ath6kl_wmi_set_roam_mode_cmd(struct wmi *wmi, enum wmi_roam_mode mode)
 				   NO_SYNC_WMIFLAG);
 }
 
-static int ath6kl_wmi_connect_event_rx(struct wmi *wmi, u8 *datap, int len,
-				       struct ath6kl_vif *vif)
+static int ath6kl_wmi_connect_event(struct wmi *wmi, u8 *datap,
+				    struct ath6kl_vif *vif, u16 beacon_ie_len,
+				    u16 assoc_req_len, u16 assoc_resp_len,
+				    u8 *assoc_info)
 {
-	struct wmi_connect_event *ev;
+	union wmi_connect_common_info *u;
 	u8 *pie, *peie;
 
-	if (len < sizeof(struct wmi_connect_event))
-		return -EINVAL;
-
-	ev = (struct wmi_connect_event *) datap;
-
+	u = (union wmi_connect_common_info *) datap;
 	if (vif->nw_type == AP_NETWORK) {
 		/* AP mode start/STA connected event */
 		struct net_device *dev = vif->ndev;
-		if (memcmp(dev->dev_addr, ev->u.ap_bss.bssid, ETH_ALEN) == 0) {
-			ath6kl_dbg(ATH6KL_DBG_WMI,
-				   "%s: freq %d bssid %pM (AP started)\n",
-				   __func__, le16_to_cpu(ev->u.ap_bss.ch),
-				   ev->u.ap_bss.bssid);
+		if (memcmp(dev->dev_addr, u->ap_bss.bssid, ETH_ALEN) == 0) {
+			ath6kl_dbg(ATH6KL_DBG_WMI, "%s: freq %d bssid %pM "
+				   "(AP started)\n",
+				   __func__, le16_to_cpu(u->ap_bss.ch),
+				   u->ap_bss.bssid);
 			ath6kl_connect_ap_mode_bss(
-				vif, le16_to_cpu(ev->u.ap_bss.ch));
+				vif, le16_to_cpu(u->ap_bss.ch));
 		} else {
-			ath6kl_dbg(ATH6KL_DBG_WMI,
-				   "%s: aid %u mac_addr %pM auth=%u keymgmt=%u cipher=%u apsd_info=%u (STA connected)\n",
-				   __func__, ev->u.ap_sta.aid,
-				   ev->u.ap_sta.mac_addr,
-				   ev->u.ap_sta.auth,
-				   ev->u.ap_sta.keymgmt,
-				   le16_to_cpu(ev->u.ap_sta.cipher),
-				   ev->u.ap_sta.apsd_info);
+			ath6kl_dbg(ATH6KL_DBG_WMI, "%s: aid %u mac_addr %pM "
+				   "auth=%u keymgmt=%u cipher=%u apsd_info=%u "
+				   "(STA connected)\n",
+				   __func__, u->ap_sta.aid,
+				   u->ap_sta.mac_addr,
+				   u->ap_sta.auth,
+				   u->ap_sta.keymgmt,
+				   le16_to_cpu(u->ap_sta.cipher),
+				   u->ap_sta.apsd_info);
 
 			ath6kl_connect_ap_mode_sta(
-				vif, ev->u.ap_sta.aid, ev->u.ap_sta.mac_addr,
-				ev->u.ap_sta.keymgmt,
-				le16_to_cpu(ev->u.ap_sta.cipher),
-				ev->u.ap_sta.auth, ev->assoc_req_len,
-				ev->assoc_info + ev->beacon_ie_len,
-				ev->u.ap_sta.apsd_info);
+				vif, u->ap_sta.aid, u->ap_sta.mac_addr,
+				u->ap_sta.keymgmt,
+				le16_to_cpu(u->ap_sta.cipher),
+				u->ap_sta.auth, assoc_req_len,
+				assoc_info + beacon_ie_len,
+				u->ap_sta.apsd_info);
 		}
 		return 0;
 	}
@@ -849,18 +848,17 @@ static int ath6kl_wmi_connect_event_rx(struct wmi *wmi, u8 *datap, int len,
 
 	ath6kl_dbg(ATH6KL_DBG_WMI,
 		   "wmi event connect freq %d bssid %pM listen_intvl %d beacon_intvl %d type %d\n",
-		   le16_to_cpu(ev->u.sta.ch), ev->u.sta.bssid,
-		   le16_to_cpu(ev->u.sta.listen_intvl),
-		   le16_to_cpu(ev->u.sta.beacon_intvl),
-		   le32_to_cpu(ev->u.sta.nw_type));
+		   le16_to_cpu(u->sta.ch), u->sta.bssid,
+		   le16_to_cpu(u->sta.listen_intvl),
+		   le16_to_cpu(u->sta.beacon_intvl),
+		   le32_to_cpu(u->sta.nw_type));
 
 	/* Start of assoc rsp IEs */
-	pie = ev->assoc_info + ev->beacon_ie_len +
-	      ev->assoc_req_len + (sizeof(u16) * 3); /* capinfo, status, aid */
+	pie = assoc_info + beacon_ie_len +
+	      assoc_req_len + (sizeof(u16) * 3); /* capinfo, status, aid */
 
 	/* End of assoc rsp IEs */
-	peie = ev->assoc_info + ev->beacon_ie_len + ev->assoc_req_len +
-	    ev->assoc_resp_len;
+	peie = assoc_info + beacon_ie_len + assoc_req_len + assoc_resp_len;
 
 	while (pie < peie) {
 		switch (*pie) {
@@ -868,8 +866,8 @@ static int ath6kl_wmi_connect_event_rx(struct wmi *wmi, u8 *datap, int len,
 			if (pie[1] > 3 && pie[2] == 0x00 && pie[3] == 0x50 &&
 			    pie[4] == 0xf2 && pie[5] == WMM_OUI_TYPE) {
 				/* WMM OUT (00:50:F2) */
-				if (pie[1] > 5 &&
-				    pie[6] == WMM_PARAM_OUI_SUBTYPE)
+				if (pie[1] > 5
+				    && pie[6] == WMM_PARAM_OUI_SUBTYPE)
 					wmi->is_wmm_enabled = true;
 			}
 			break;
@@ -881,17 +879,47 @@ static int ath6kl_wmi_connect_event_rx(struct wmi *wmi, u8 *datap, int len,
 		pie += pie[1] + 2;
 	}
 
-	ath6kl_connect_event(vif, le16_to_cpu(ev->u.sta.ch),
-			     ev->u.sta.bssid,
-			     le16_to_cpu(ev->u.sta.listen_intvl),
-			     le16_to_cpu(ev->u.sta.beacon_intvl),
-			     le32_to_cpu(ev->u.sta.nw_type),
-			     ev->beacon_ie_len, ev->assoc_req_len,
-			     ev->assoc_resp_len, ev->assoc_info);
+	ath6kl_connect_event(vif, le16_to_cpu(u->sta.ch),
+			     u->sta.bssid,
+			     le16_to_cpu(u->sta.listen_intvl),
+			     le16_to_cpu(u->sta.beacon_intvl),
+			     le32_to_cpu(u->sta.nw_type),
+			     beacon_ie_len, assoc_req_len,
+			     assoc_resp_len, assoc_info);
 
 	return 0;
 }
 
+static int ath6kl_wmi_connect_event_rx_advanced(struct wmi *wmi, u8 *datap,
+						int len, struct ath6kl_vif *vif)
+{
+	struct wmi_connect_event_advanced *ev;
+
+	if (len < sizeof(struct wmi_connect_event_advanced))
+		return -EINVAL;
+
+	ev = (struct wmi_connect_event_advanced *) datap;
+
+	return ath6kl_wmi_connect_event(wmi, datap, vif, ev->beacon_ie_len,
+					ev->assoc_req_len, ev->assoc_resp_len,
+					ev->assoc_info);
+}
+
+static int ath6kl_wmi_connect_event_rx(struct wmi *wmi, u8 *datap, int len,
+				       struct ath6kl_vif *vif)
+{
+	struct wmi_connect_event *ev;
+
+	if (len < sizeof(struct wmi_connect_event))
+		return -EINVAL;
+
+	ev = (struct wmi_connect_event *) datap;
+
+	return ath6kl_wmi_connect_event(wmi, datap, vif, ev->beacon_ie_len,
+					ev->assoc_req_len, ev->assoc_resp_len,
+					ev->assoc_info);
+}
+
 static struct country_code_to_enum_rd *
 ath6kl_regd_find_country(u16 countryCode)
 {
@@ -3850,6 +3878,7 @@ static int ath6kl_wmi_proc_events_vif(struct wmi *wmi, u16 if_idx, u16 cmd_id,
 					u8 *datap, u32 len)
 {
 	struct ath6kl_vif *vif;
+	struct ath6kl *ar;
 
 	vif = ath6kl_get_vif_by_index(wmi->parent_dev, if_idx);
 	if (!vif) {
@@ -3858,11 +3887,17 @@ static int ath6kl_wmi_proc_events_vif(struct wmi *wmi, u16 if_idx, u16 cmd_id,
 			    if_idx);
 		return -EINVAL;
 	}
+  ar = vif->ar;
 
 	switch (cmd_id) {
 	case WMI_CONNECT_EVENTID:
 		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_CONNECT_EVENTID\n");
-		return ath6kl_wmi_connect_event_rx(wmi, datap, len, vif);
+		if (test_bit(ATH6KL_FW_CAPABILITY_LARGE_CONNECT_IE,
+			     ar->fw_capabilities))
+			return ath6kl_wmi_connect_event_rx_advanced(wmi, datap,
+								   len, vif);
+		else
+			return ath6kl_wmi_connect_event_rx(wmi, datap, len, vif);
 	case WMI_DISCONNECT_EVENTID:
 		ath6kl_dbg(ATH6KL_DBG_WMI, "WMI_DISCONNECT_EVENTID\n");
 		return ath6kl_wmi_disconnect_event_rx(wmi, datap, len, vif);
diff --git a/drivers/net/wireless/ath/ath6kl/wmi.h b/drivers/net/wireless/ath/ath6kl/wmi.h
index b5f2265..dd67475 100644
--- a/drivers/net/wireless/ath/ath6kl/wmi.h
+++ b/drivers/net/wireless/ath/ath6kl/wmi.h
@@ -1517,38 +1517,51 @@ enum wmi_phy_cap {
 	WMI_11AGN_CAP = 0x06,
 };
 
+union wmi_connect_common_info {
+	struct {
+		__le16 ch;
+		u8 bssid[ETH_ALEN];
+		__le16 listen_intvl;
+		__le16 beacon_intvl;
+		__le32 nw_type;
+	} sta;
+	struct {
+		u8 phymode;
+		u8 aid;
+		u8 mac_addr[ETH_ALEN];
+		u8 auth;
+		u8 keymgmt;
+		__le16 cipher;
+		u8 apsd_info;
+		u8 unused[3];
+	} ap_sta;
+	struct {
+		__le16 ch;
+		u8 bssid[ETH_ALEN];
+		u8 unused[8];
+	} ap_bss;
+} __packed;
+
+
 /* Connect Event */
 struct wmi_connect_event {
-	union {
-		struct {
-			__le16 ch;
-			u8 bssid[ETH_ALEN];
-			__le16 listen_intvl;
-			__le16 beacon_intvl;
-			__le32 nw_type;
-		} sta;
-		struct {
-			u8 phymode;
-			u8 aid;
-			u8 mac_addr[ETH_ALEN];
-			u8 auth;
-			u8 keymgmt;
-			__le16 cipher;
-			u8 apsd_info;
-			u8 unused[3];
-		} ap_sta;
-		struct {
-			__le16 ch;
-			u8 bssid[ETH_ALEN];
-			u8 unused[8];
-		} ap_bss;
-	} u;
+ 	union wmi_connect_common_info u;
 	u8 beacon_ie_len;
 	u8 assoc_req_len;
 	u8 assoc_resp_len;
 	u8 assoc_info[1];
 } __packed;
 
+/* Connect Event for large IE*/
+struct wmi_connect_event_advanced {
+	union wmi_connect_common_info u;
+	u16 beacon_ie_len;
+	u16 assoc_req_len;
+	u16 assoc_resp_len;
+	u8 assoc_info[1];
+} __packed;
+
+
 /* Disconnect Event */
 enum wmi_disconnect_reason {
 	NO_NETWORK_AVAIL = 0x01,
-- 
1.9.1

