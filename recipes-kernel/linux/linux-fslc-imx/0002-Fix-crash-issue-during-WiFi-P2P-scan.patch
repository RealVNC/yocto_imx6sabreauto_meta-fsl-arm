From 6d687e209a43e1a04f7625c0b05dd9705e048f5e Mon Sep 17 00:00:00 2001
From: Yun Jiang <Yun.Jiang@vncautomotive.com>
Date: Fri, 4 Nov 2016 13:52:51 +0000
Subject: [PATCH 2/4] Fix crash issue during WiFi P2P scan.

---
 drivers/net/wireless/ath/ath6kl/cfg80211.c | 45 ++++++++++++++++++++++--------
 drivers/net/wireless/ath/ath6kl/wmi.c      | 37 ++++++++++++++++++------
 2 files changed, 63 insertions(+), 19 deletions(-)

diff --git a/drivers/net/wireless/ath/ath6kl/cfg80211.c b/drivers/net/wireless/ath/ath6kl/cfg80211.c
index 9556d4e..8962fdbc 100644
--- a/drivers/net/wireless/ath/ath6kl/cfg80211.c
+++ b/drivers/net/wireless/ath/ath6kl/cfg80211.c
@@ -856,9 +856,15 @@ void ath6kl_cfg80211_disconnect_event(struct ath6kl_vif *vif, u8 reason,
 {
 	struct ath6kl *ar = vif->ar;
 
-	if (vif->scan_req) {
-		cfg80211_scan_done(vif->scan_req, true);
-		vif->scan_req = NULL;
+	struct cfg80211_scan_request *scan_req;
+
+	spin_lock_bh(&vif->if_lock);
+	scan_req = vif->scan_req;
+	vif->scan_req = NULL;
+	spin_unlock_bh(&vif->if_lock);
+
+	if (scan_req) {
+		cfg80211_scan_done(scan_req, true);
 	}
 
 	if (vif->nw_type & ADHOC_NETWORK) {
@@ -1050,7 +1056,9 @@ static int ath6kl_cfg80211_scan(struct wiphy *wiphy,
 	if (test_bit(CONNECTED, &vif->flags))
 		force_fg_scan = 1;
 
+	spin_lock_bh(&vif->if_lock);
 	vif->scan_req = request;
+	spin_unlock_bh(&vif->if_lock);
 
 	ret = ath6kl_wmi_beginscan_cmd(ar->wmi, vif->fw_vif_idx,
 				       WMI_LONG_SCAN, force_fg_scan,
@@ -1061,7 +1069,9 @@ static int ath6kl_cfg80211_scan(struct wiphy *wiphy,
 				       request->rates);
 	if (ret) {
 		ath6kl_err("failed to start scan: %d\n", ret);
+		spin_lock_bh(&vif->if_lock);
 		vif->scan_req = NULL;
+		spin_unlock_bh(&vif->if_lock);
 	}
 
 	kfree(channels);
@@ -1072,19 +1082,28 @@ static int ath6kl_cfg80211_scan(struct wiphy *wiphy,
 void ath6kl_cfg80211_scan_complete_event(struct ath6kl_vif *vif, bool aborted)
 {
 	struct ath6kl *ar = vif->ar;
+	struct cfg80211_scan_request *request = NULL;
 	int i;
 
 	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "%s: status%s\n", __func__,
 		   aborted ? " aborted" : "");
 
-	if (!vif->scan_req)
+	spin_lock_bh(&vif->if_lock);
+	if (!vif->scan_req) {
+		spin_unlock_bh(&vif->if_lock);
 		return;
+	}
+
+	request = vif->scan_req;
+	vif->scan_req = NULL;
+	spin_unlock_bh(&vif->if_lock);
 
 	if (aborted)
 		goto out;
 
-	if (vif->scan_req->n_ssids && vif->scan_req->ssids[0].ssid_len) {
-		for (i = 0; i < vif->scan_req->n_ssids; i++) {
+	if (request->n_ssids && request->ssids &&
+	    request->ssids[0].ssid_len) {
+		for (i = 0; i < request->n_ssids; i++) {
 			ath6kl_wmi_probedssid_cmd(ar->wmi, vif->fw_vif_idx,
 						  i + 1, DISABLE_SSID_FLAG,
 						  0, NULL);
@@ -1092,8 +1111,7 @@ void ath6kl_cfg80211_scan_complete_event(struct ath6kl_vif *vif, bool aborted)
 	}
 
 out:
-	cfg80211_scan_done(vif->scan_req, aborted);
-	vif->scan_req = NULL;
+	cfg80211_scan_done(request, aborted);
 }
 
 void ath6kl_cfg80211_ch_switch_notify(struct ath6kl_vif *vif, int freq,
@@ -3575,6 +3593,7 @@ static int ath6kl_cfg80211_vif_init(struct ath6kl_vif *vif)
 void ath6kl_cfg80211_vif_stop(struct ath6kl_vif *vif, bool wmi_ready)
 {
 	static u8 bcast_mac[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+	struct cfg80211_scan_request *scan_req;
 	bool discon_issued;
 
 	netif_stop_queue(vif->ndev);
@@ -3594,9 +3613,13 @@ void ath6kl_cfg80211_vif_stop(struct ath6kl_vif *vif, bool wmi_ready)
 						0, NULL, 0);
 	}
 
-	if (vif->scan_req) {
-		cfg80211_scan_done(vif->scan_req, true);
-		vif->scan_req = NULL;
+	spin_lock_bh(&vif->if_lock);
+	scan_req = vif->scan_req;
+	vif->scan_req = NULL;
+	spin_unlock_bh(&vif->if_lock);
+
+	if (scan_req) {
+		cfg80211_scan_done(scan_req, true);
 	}
 
 	/* need to clean up enhanced bmiss detection fw state */
diff --git a/drivers/net/wireless/ath/ath6kl/wmi.c b/drivers/net/wireless/ath/ath6kl/wmi.c
index 79c9a00..b9baa5c 100644
--- a/drivers/net/wireless/ath/ath6kl/wmi.c
+++ b/drivers/net/wireless/ath/ath6kl/wmi.c
@@ -523,6 +523,8 @@ static int ath6kl_wmi_tx_status_event_rx(struct wmi *wmi, u8 *datap, int len,
 					 struct ath6kl_vif *vif)
 {
 	struct wmi_tx_status_event *ev;
+	u8 *last_mgmt_tx_frame = NULL;
+	size_t last_mgmt_tx_frame_len = 0;
 	u32 id;
 
 	if (len < sizeof(*ev))
@@ -532,14 +534,20 @@ static int ath6kl_wmi_tx_status_event_rx(struct wmi *wmi, u8 *datap, int len,
 	id = le32_to_cpu(ev->id);
 	ath6kl_dbg(ATH6KL_DBG_WMI, "tx_status: id=%x ack_status=%u\n",
 		   id, ev->ack_status);
-	if (wmi->last_mgmt_tx_frame) {
+
+	spin_lock_bh(&wmi->lock);
+	last_mgmt_tx_frame = wmi->last_mgmt_tx_frame;
+	last_mgmt_tx_frame_len = wmi->last_mgmt_tx_frame_len;
+	wmi->last_mgmt_tx_frame = NULL;
+	wmi->last_mgmt_tx_frame_len = 0;
+	spin_unlock_bh(&wmi->lock);
+
+	if (last_mgmt_tx_frame) {
 		cfg80211_mgmt_tx_status(&vif->wdev, id,
-					wmi->last_mgmt_tx_frame,
-					wmi->last_mgmt_tx_frame_len,
+					last_mgmt_tx_frame,
+					last_mgmt_tx_frame_len,
 					!!ev->ack_status, GFP_ATOMIC);
-		kfree(wmi->last_mgmt_tx_frame);
-		wmi->last_mgmt_tx_frame = NULL;
-		wmi->last_mgmt_tx_frame_len = 0;
+		kfree(last_mgmt_tx_frame);
 	}
 
 	return 0;
@@ -691,6 +699,7 @@ static int ath6kl_wmi_simple_cmd(struct wmi *wmi, u8 if_idx,
 static int ath6kl_wmi_ready_event_rx(struct wmi *wmi, u8 *datap, int len)
 {
 	struct wmi_ready_event_2 *ev = (struct wmi_ready_event_2 *) datap;
+	struct ath6kl *ar = wmi->parent_dev;
 
 	if (len < sizeof(struct wmi_ready_event_2))
 		return -EINVAL;
@@ -742,6 +751,7 @@ int ath6kl_wmi_force_roam_cmd(struct wmi *wmi, const u8 *bssid)
 		return -ENOMEM;
 
 	cmd = (struct roam_ctrl_cmd *) skb->data;
+	memset(cmd, 0, sizeof(*cmd));
 
 	memcpy(cmd->info.bssid, bssid, ETH_ALEN);
 	cmd->roam_ctrl = WMI_FORCE_ROAM;
@@ -794,6 +804,7 @@ int ath6kl_wmi_set_roam_mode_cmd(struct wmi *wmi, enum wmi_roam_mode mode)
 		return -ENOMEM;
 
 	cmd = (struct roam_ctrl_cmd *) skb->data;
+	memset(cmd, 0, sizeof(*cmd));
 
 	cmd->info.roam_mode = mode;
 	cmd->roam_ctrl = WMI_SET_ROAM_MODE;
@@ -3646,10 +3657,13 @@ static int ath6kl_wmi_send_action_cmd(struct wmi *wmi, u8 if_idx, u32 id,
 		return -ENOMEM;
 	}
 
-	kfree(wmi->last_mgmt_tx_frame);
 	memcpy(buf, data, data_len);
+
+	spin_lock_bh(&wmi->lock);
+	kfree(wmi->last_mgmt_tx_frame);
 	wmi->last_mgmt_tx_frame = buf;
 	wmi->last_mgmt_tx_frame_len = data_len;
+	spin_unlock_bh(&wmi->lock);
 
 	ath6kl_dbg(ATH6KL_DBG_WMI,
 		   "send_action_cmd: id=%u freq=%u wait=%u len=%u\n",
@@ -3685,10 +3699,13 @@ static int __ath6kl_wmi_send_mgmt_cmd(struct wmi *wmi, u8 if_idx, u32 id,
 		return -ENOMEM;
 	}
 
-	kfree(wmi->last_mgmt_tx_frame);
 	memcpy(buf, data, data_len);
+
+	spin_lock_bh(&wmi->lock);
+	kfree(wmi->last_mgmt_tx_frame);
 	wmi->last_mgmt_tx_frame = buf;
 	wmi->last_mgmt_tx_frame_len = data_len;
+	spin_unlock_bh(&wmi->lock);
 
 	ath6kl_dbg(ATH6KL_DBG_WMI,
 		   "send_action_cmd: id=%u freq=%u wait=%u len=%u\n",
@@ -4163,6 +4180,10 @@ void ath6kl_wmi_shutdown(struct wmi *wmi)
 	if (!wmi)
 		return;
 
+	spin_lock_bh(&wmi->lock);
 	kfree(wmi->last_mgmt_tx_frame);
+	wmi->last_mgmt_tx_frame = NULL;
+	spin_unlock_bh(&wmi->lock);
+
 	kfree(wmi);
 }
-- 
1.9.1

